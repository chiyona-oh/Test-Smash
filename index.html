<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ì‹œí—˜ê¸°ê°„ ìŠ¤íŠ¸ë ˆìŠ¤ í•´ì†Œìš© ì‹œí—˜ì§€ ë¿Œì‹œê¸° ê²Œì„</title>
  <style>
    :root { --w: 360px; }

    html, body { height: 100%; }
    body {
      margin: 0;
      background: #111;
      color: #fff;
      font-family: system-ui, sans-serif;
      overflow: hidden; /* ëª¨ë°”ì¼ì—ì„œ ìŠ¤í¬ë¡¤ë¡œ í™”ë©´ì´ ë°€ë¦¬ëŠ” ê²ƒ ë°©ì§€ */
    }

    .wrap {
      height: 100dvh; /* ëª¨ë°”ì¼ ë™ì  ë†’ì´ */
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 10px 10px calc(10px + env(safe-area-inset-bottom));
      box-sizing: border-box;
    }

    .title {
      width: min(var(--w), 96vw);
      font-size: 16px;
      font-weight: 800;
      padding: 10px 12px;
      border-radius: 14px;
      text-align: center;
      color: #ffe66b;
      background: linear-gradient(180deg, rgba(255,230,107,0.10), rgba(0,0,0,0.25));
      border: 1px solid rgba(255,230,107,0.35);
      text-shadow: 0 1px 0 rgba(0,0,0,0.55);
      letter-spacing: -0.2px;
      flex: 0 0 auto;
    }

    .hud {
      width: min(var(--w), 96vw);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      font-size: 13px;
      opacity: 0.95;
      flex: 0 0 auto;
    }
    .hud > div {
      background: rgba(255,255,255,0.06);
      padding: 8px 10px;
      border-radius: 10px;
      box-sizing: border-box;
    }

    /* ìº”ë²„ìŠ¤ëŠ” ë‚¨ëŠ” ê³µê°„ì„ ì „ë¶€ ë¨¹ë„ë¡ */
    .game-wrap {
      width: min(var(--w), 96vw);
      flex: 1 1 auto;
      display: flex;
      align-items: stretch;
    }

    canvas {
      width: 100%;
      height: 100%; /* ë¶€ëª¨ ë†’ì´ì— ë§ì¶¤ */
      background: #1b1b1b;
      border: 1px solid #333;
      border-radius: 12px;
      touch-action: manipulation;
      display: block;
    }

    .btns {
      width: min(var(--w), 96vw);
      display: flex;
      gap: 8px;
      flex: 0 0 auto;
    }
    button {
      flex: 1;
      padding: 10px 12px;
      border-radius: 10px;
      border: 0;
      cursor: pointer;
    }

    .footer {
      width: min(var(--w), 96vw);
      text-align: center;
      font-size: 12px;
      opacity: 0.65;
      padding: 2px 0 0;
      flex: 0 0 auto;
    }

    /* ì‘ì€ í™”ë©´ì—ì„œ íƒ€ì´í‹€/ê¸€ í¬ê¸° ì‚´ì§ ì¤„ì—¬ í•œ í™”ë©´ì— ë” ì˜ ë“¤ì–´ì˜¤ê²Œ */
    @media (max-height: 700px) {
      .title { font-size: 15px; padding: 8px 10px; }
      .hud { font-size: 12px; }
      button { padding: 9px 10px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="title">ì‹œí—˜ê¸°ê°„ ìŠ¤íŠ¸ë ˆìŠ¤ í•´ì†Œìš© ì‹œí—˜ì§€ ë¿Œì‹œê¸° ê²Œì„</div>

    <div class="hud">
      <div id="grade">í•™ë…„: ì¤‘í•™êµ 1í•™ë…„</div>
      <div id="progress">ì§„í–‰: 0 / 10 (í´ë¦­: 0)</div>
    </div>

    <div class="game-wrap">
      <!-- JSì—ì„œ ë‚´ë¶€ í•´ìƒë„(canvas.width/height)ë¥¼ ê¸°ê¸° í”½ì…€ì— ë§ê²Œ ì¡°ì • -->
      <canvas id="game"></canvas>
    </div>

    <div class="btns">
      <button id="startBtn">ì‹œì‘</button>
      <button id="restartBtn">ë¦¬ì…‹</button>
      <button id="muteBtn">ğŸ”Š ìŒì•…</button>
    </div>

    <div class="footer">Created by Chiyona</div>
  </div>

  <script>
    // ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
    if (window.__PAPER_GAME_LOADED__) {
      console.warn("Game already loaded - preventing duplicate init.");
      throw new Error("Duplicate load prevented");
    }
    window.__PAPER_GAME_LOADED__ = true;

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d", { alpha: false });

    const gradeEl = document.getElementById("grade");
    const progressEl = document.getElementById("progress");

    const startBtn = document.getElementById("startBtn");
    const restartBtn = document.getElementById("restartBtn");
    const muteBtn = document.getElementById("muteBtn");

    // ====== ìŠ¤í…Œì´ì§€ ê·œì¹™ ======
    const STAGES = [
      { label: "ì¤‘í•™êµ 1í•™ë…„", total: 10, pass: 5,  school: "middle" },
      { label: "ì¤‘í•™êµ 2í•™ë…„", total: 15, pass: 10, school: "middle" },
      { label: "ì¤‘í•™êµ 3í•™ë…„", total: 20, pass: 15, school: "middle" },
      { label: "ê³ ë“±í•™êµ 1í•™ë…„", total: 25, pass: 20, school: "high"   },
      { label: "ê³ ë“±í•™êµ 2í•™ë…„", total: 30, pass: 25, school: "high"   },
      { label: "ê³ ë“±í•™êµ 3í•™ë…„", total: 35, pass: 30, school: "high"   },
    ];

    // ====== ìº”ë²„ìŠ¤ ë¦¬ì‚¬ì´ì¦ˆ(ëª¨ë°”ì¼ í™”ë©´ì— ë”± ë§ê²Œ) ======
    function resizeCanvasToCSS() {
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.min(window.devicePixelRatio || 1, 2); // ê³¼ë„í•œ DPRì€ ì„±ëŠ¥ ë¶€ë‹´ â†’ 2ë¡œ ì œí•œ

      const w = Math.max(1, Math.floor(rect.width * dpr));
      const h = Math.max(1, Math.floor(rect.height * dpr));

      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
    }

    window.addEventListener("resize", () => {
      resizeCanvasToCSS();
      draw(); // í™”ë©´ ë³€ê²½ ì¦‰ì‹œ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
    });

    // ====== ë¹„ì£¼ì–¼ ======
    const PAPER_W = 92;
    const PAPER_H = 58;

    function getPaperStyle() {
      const school = STAGES[stageIndex].school;
      if (school === "high") {
        return {
          fill: "#ffe66b",
          stroke: "rgba(0,0,0,0.45)",
          line: "rgba(0,0,0,0.18)",
          text: "rgba(0,0,0,0.78)"
        };
      }
      return {
        fill: "#f4f4f4",
        stroke: "rgba(0,0,0,0.35)",
        line: "rgba(0,0,0,0.15)",
        text: "rgba(0,0,0,0.72)"
      };
    }

    // ====== ë‚œì´ë„ ======
    function getSpawnIntervalMs() {
      const base = 520;
      const perStage = 45 * stageIndex;
      const highBoost = (STAGES[stageIndex].school === "high") ? 80 : 0;
      return Math.max(160, base - perStage - highBoost);
    }

    function getFallSpeed() {
      const baseMin = 260;
      const baseMax = 380;

      const perStageMin = 22 * stageIndex;
      const perStageMax = 30 * stageIndex;

      const highAddMin = (STAGES[stageIndex].school === "high") ? 60 : 0;
      const highAddMax = (STAGES[stageIndex].school === "high") ? 90 : 0;

      const min = baseMin + perStageMin + highAddMin;
      const max = baseMax + perStageMax + highAddMax;

      return min + Math.random() * (max - min);
    }

    // ====== ì˜¤ë””ì˜¤ (ëª¨ë°”ì¼ ê°•í™”) ======
    let audioCtx = null;
    let musicOn = true;
    let bgmTimer = null;

    function ensureAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioCtx;
    }

    async function unlockAudio() {
      // ëª¨ë°”ì¼ì€ ì‚¬ìš©ì ì œìŠ¤ì²˜ ì´í›„ì—ë§Œ resumeì´ ì„±ê³µí•©ë‹ˆë‹¤.
      const ac = ensureAudio();
      if (ac.state === "suspended") {
        try { await ac.resume(); } catch (e) {}
      }
    }

    function playTone(freq, durationSec, type = "sine", gain = 0.06) {
      const ac = ensureAudio();
      const now = ac.currentTime;

      const o = ac.createOscillator();
      const g = ac.createGain();

      o.type = type;
      o.frequency.value = freq;

      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(gain, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + durationSec);

      o.connect(g);
      g.connect(ac.destination);

      o.start(now);
      o.stop(now + durationSec + 0.02);
    }

    function startBgm() {
      if (!musicOn) return;
      stopBgm();

      const seq = [523.25, 659.25, 783.99, 659.25, 587.33, 659.25, 523.25, 392.00];
      let idx = 0;

      bgmTimer = setInterval(() => {
        if (!musicOn) return;
        // AudioContextê°€ ë‹¤ì‹œ suspended ë  ìˆ˜ ìˆìœ¼ë‹ˆ ë°©ì–´
        if (!audioCtx || audioCtx.state !== "running") return;
        playTone(seq[idx % seq.length], 0.18, "square", 0.045);
        idx++;
      }, 210);
    }

    function stopBgm() {
      if (bgmTimer) {
        clearInterval(bgmTimer);
        bgmTimer = null;
      }
    }

    function playSuccessJingle() {
      if (!musicOn) return;
      if (!audioCtx || audioCtx.state !== "running") return;

      const notes = [523.25, 659.25, 783.99, 1046.50];
      let t = 0;
      for (const f of notes) {
        setTimeout(() => {
          if (audioCtx && audioCtx.state === "running") {
            playTone(f, 0.16, "triangle", 0.08);
          }
        }, t);
        t += 170;
      }
    }

    function toggleMusic() {
      musicOn = !musicOn;
      muteBtn.textContent = musicOn ? "ğŸ”Š ìŒì•…" : "ğŸ”‡ ë¬´ìŒ";
      if (!musicOn) stopBgm();
      else if (running) startBgm();
    }

    // ====== ê²Œì„ ìƒíƒœ ======
    let stageIndex = 0;

    let running = false;
    let stageActive = false;
    let pausedOverlay = false;

    const papers = [];
    let lastTime = 0;
    let lastSpawn = 0;

    let resolvedCount = 0;
    let hitCount = 0;

    let overlay = null; // { type, until, text1, text2 }

    function currentStage() {
      return STAGES[stageIndex];
    }

    function updateHUD() {
      const s = currentStage();
      gradeEl.textContent = `í•™ë…„: ${s.label}`;
      progressEl.textContent = `ì§„í–‰: ${resolvedCount} / ${s.total} (í´ë¦­: ${hitCount})`;
    }

    function startStage() {
      stageActive = true;
      pausedOverlay = false;
      overlay = null;

      resolvedCount = 0;
      hitCount = 0;
      papers.length = 0;

      lastSpawn = 0;
      updateHUD();
    }

    function resetGame() {
      running = false;
      stageActive = false;
      pausedOverlay = false;

      stageIndex = 0;
      resolvedCount = 0;
      hitCount = 0;

      papers.length = 0;
      lastTime = 0;
      lastSpawn = 0;
      overlay = null;

      stopBgm();
      draw();
      updateHUD();
    }

    function startLoopIfNeeded() {
      if (running) return;
      running = true;
      lastTime = performance.now();
      if (musicOn && audioCtx && audioCtx.state === "running") startBgm();
      requestAnimationFrame(loop);
    }

    function spawnPaper() {
      // canvas ë‚´ë¶€ ì¢Œí‘œê³„(í”½ì…€) ê¸°ì¤€ìœ¼ë¡œ ìƒì„±í•´ì•¼ í•¨
      const w = canvas.width;
      const h = canvas.height;

      // ìº”ë²„ìŠ¤ ë¦¬ì‚¬ì´ì¦ˆ ì‹œ DPRì´ ì ìš©ë˜ë¯€ë¡œ ì¢…ì´ í¬ê¸°ë„ DPRì— ë§ì¶° ìŠ¤ì¼€ì¼
      // ë‹¤ë§Œ ë„ˆë¬´ ì»¤ì§€ë©´ ê²Œì„ ë‚œì´ë„ê°€ ë°”ë€Œë¯€ë¡œ "í™”ë©´ ë¹„ìœ¨" ìœ ì§€ìš©ìœ¼ë¡œ í­ ê¸°ì¤€ ìŠ¤ì¼€ì¼
      const scale = Math.max(0.85, Math.min(1.25, w / (360 * Math.min(window.devicePixelRatio || 1, 2))));

      const pw = PAPER_W * scale;
      const ph = PAPER_H * scale;

      const x = Math.random() * Math.max(1, (w - pw));
      const y = -ph;
      const speed = getFallSpeed() * scale;

      papers.push({ x, y, w: pw, h: ph, speed });
    }

    function loop(t) {
      if (!running) return;

      const dt = (t - lastTime) / 1000;
      lastTime = t;

      if (stageActive && !pausedOverlay) {
        const s = currentStage();
        const interval = getSpawnIntervalMs();

        if (resolvedCount + papers.length < s.total) {
          if (t - lastSpawn > interval) {
            spawnPaper();
            lastSpawn = t;
          }
        }

        for (let i = papers.length - 1; i >= 0; i--) {
          papers[i].y += papers[i].speed * dt;

          if (papers[i].y > canvas.height) {
            papers.splice(i, 1);
            resolvedCount += 1;
            checkStageEnd(t);
          }
        }

        checkStageEnd(t);
      }

      draw();

      if (overlay && t < overlay.until) {
        drawOverlay(overlay.type, overlay.text1, overlay.text2);
      } else if (overlay && t >= overlay.until) {
        const wasSuccess = overlay.type === "success";
        overlay = null;

        if (wasSuccess) {
          // ì„±ê³µ í›„: ìë™ ì§„í–‰ ê¸ˆì§€ â†’ ë©ˆì¶”ê³  Startë¥¼ ëˆ„ë¥´ë©´ ë‹¤ìŒ ì‹œì‘
          stageActive = false;
          pausedOverlay = false;

          if (stageIndex + 1 < STAGES.length) {
            stageIndex += 1;
            updateHUD();
            drawOverlay("success", "ì„±ê³µ!", "ë‹¤ìŒ ë‹¨ê³„ëŠ” ì‹œì‘ì„ ëˆ„ë¥´ì„¸ìš”");
          } else {
            running = false;
            stopBgm();
            drawOverlay("success", "ì „ë¶€ í†µê³¼!", "ê³ 3ê¹Œì§€ í´ë¦¬ì–´!");
          }
        } else {
          running = false;
          stopBgm();
          drawFailFinal();
        }
      }

      updateHUD();

      if (running) requestAnimationFrame(loop);
    }

    function checkStageEnd(t) {
      const s = currentStage();
      const allSpawned = (resolvedCount + papers.length) >= s.total;

      if (allSpawned && papers.length === 0) {
        pausedOverlay = true;

        if (hitCount >= s.pass) {
          overlay = { type: "success", until: t + 1200, text1: "ì„±ê³µ!", text2: `${s.label} í†µê³¼!` };
          playSuccessJingle();
        } else {
          overlay = { type: "fail", until: t + 1400, text1: "ì‹¤íŒ¨!", text2: `í´ë¦­ ${hitCount}ê°œ (í•„ìš”: ${s.pass}ê°œ)` };
        }
      }
    }

    function draw() {
      // ë°°ê²½
      ctx.fillStyle = "#1b1b1b";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // ìƒë‹¨ ì–‡ì€ ë°”(í…ìŠ¤íŠ¸ ì—†ìŒ)
      ctx.fillStyle = "rgba(255,255,255,0.04)";
      ctx.fillRect(0, 0, canvas.width, Math.min(44, canvas.height * 0.10));

      const style = getPaperStyle();

      for (const p of papers) {
        ctx.fillStyle = style.fill;
        ctx.fillRect(p.x, p.y, p.w, p.h);

        ctx.strokeStyle = style.stroke;
        ctx.strokeRect(p.x, p.y, p.w, p.h);

        ctx.fillStyle = style.line;
        ctx.fillRect(p.x + 10, p.y + 14, p.w - 20, 3);
        ctx.fillRect(p.x + 10, p.y + 24, p.w - 34, 3);
        ctx.fillRect(p.x + 10, p.y + 34, p.w - 26, 3);

        ctx.fillStyle = style.text;
        ctx.font = `${Math.max(12, Math.floor(p.h * 0.22))}px system-ui`;
        ctx.fillText("ì‹œí—˜ì§€", p.x + 10, p.y + p.h - 8);
      }

      // ë°”ë‹¥ì„ 
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.beginPath();
      ctx.moveTo(0, canvas.height - 1);
      ctx.lineTo(canvas.width, canvas.height - 1);
      ctx.stroke();

      // ëŒ€ê¸° ì•ˆë‚´
      if (!running) {
        drawDimText("ì‹œì‘ì„ ëˆŒëŸ¬ í”Œë ˆì´");
      } else if (!stageActive) {
        drawDimText("ì‹œì‘ì„ ëˆŒëŸ¬ ìŠ¤í…Œì´ì§€ ì‹œì‘");
      }
    }

    function drawDimText(text) {
      ctx.fillStyle = "rgba(0,0,0,0.40)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.textAlign = "center";
      ctx.fillStyle = "#fff";
      ctx.font = `${Math.max(16, Math.floor(canvas.height * 0.03))}px system-ui`;
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);
      ctx.textAlign = "start";
    }

    function drawOverlay(type, text1, text2) {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.textAlign = "center";
      ctx.fillStyle = "#fff";
      ctx.font = `${Math.max(26, Math.floor(canvas.height * 0.05))}px system-ui`;
      ctx.fillText(text1, canvas.width / 2, canvas.height / 2 - 12);

      ctx.font = `${Math.max(14, Math.floor(canvas.height * 0.028))}px system-ui`;
      ctx.fillText(text2, canvas.width / 2, canvas.height / 2 + 22);
      ctx.textAlign = "start";
    }

    function drawFailFinal() {
      const s = currentStage();

      ctx.fillStyle = "rgba(0,0,0,0.60)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = `${Math.max(24, Math.floor(canvas.height * 0.05))}px system-ui`;
      ctx.fillText("FAILED", canvas.width / 2, canvas.height / 2 - 26);

      ctx.font = `${Math.max(14, Math.floor(canvas.height * 0.028))}px system-ui`;
      ctx.fillText(`${s.label}ì—ì„œ ì‹¤íŒ¨`, canvas.width / 2, canvas.height / 2 + 6);
      ctx.fillText(`í´ë¦­ ${hitCount}ê°œ / í•„ìš” ${s.pass}ê°œ`, canvas.width / 2, canvas.height / 2 + 30);
      ctx.fillText("ë¦¬ì…‹ì„ ëˆŒëŸ¬ ë‹¤ì‹œ ì‹œì‘", canvas.width / 2, canvas.height / 2 + 56);

      ctx.textAlign = "start";
    }

    // ì…ë ¥(í„°ì¹˜/í´ë¦­)
    function getPointerXY(e) {
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      const x = (e.clientX - rect.left) * dpr;
      const y = (e.clientY - rect.top) * dpr;
      return { x, y };
    }

    function handlePointer(e) {
      if (!running || !stageActive || pausedOverlay) return;

      const { x, y } = getPointerXY(e);

      for (let i = papers.length - 1; i >= 0; i--) {
        const p = papers[i];
        if (x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h) {
          papers.splice(i, 1);
          hitCount += 1;
          resolvedCount += 1;
          return;
        }
      }
    }

    // ëª¨ë°”ì¼ ì†Œë¦¬ ë¬¸ì œ ëŒ€ì‘: ìº”ë²„ìŠ¤ë¥¼ íƒ­í•´ë„ ì˜¤ë””ì˜¤ unlock ì‹œë„
    canvas.addEventListener("pointerdown", async (e) => {
      await unlockAudio();
      if (musicOn && running && !bgmTimer && audioCtx && audioCtx.state === "running") {
        startBgm();
      }
      handlePointer(e);
    });

    startBtn.addEventListener("click", async () => {
      await unlockAudio();
      resizeCanvasToCSS(); // ì‹œì‘ ëˆ„ë¥¼ ë•Œ í™”ë©´ í¬ê¸° í™•ì •

      startLoopIfNeeded();

      if (!stageActive) {
        startStage();
      }

      // BGM ë³´ì¥
      if (musicOn && audioCtx && audioCtx.state === "running") startBgm();
    });

    restartBtn.addEventListener("click", () => {
      resetGame();
    });

    muteBtn.addEventListener("click", async () => {
      await unlockAudio();
      toggleMusic();
    });

    // ì´ˆê¸°í™”(ë¡œë“œ ì‹œ ìº”ë²„ìŠ¤ í¬ê¸° ë§ì¶”ê¸°)
    resizeCanvasToCSS();
    updateHUD();
    draw();
  </script>
</body>
</html>
